#region Объявление
// Массив представляет набор однотипных данных. Объявление массива похоже на
// объявление переменной за тем исключением, что после указания типа ставятся
// квадратные скобки

// тип_переменной[] название_массива;

int[] numbers;

int[] nums = new int[4];  // new, мы выделили память для 4 элементов массива.
                          // При таком определении все элементы получают значение по умолчанию, которое предусмотренно для их типа

// Мы можем сразу указать значения для элементов
int[] nums1 = new int[4] { 1, 2, 3, 4 };
int[] nums2 = new int[] { 1, 2, 3, 4 };
int[] nums3 = new[] { 1, 2, 3, 4 };
int[] nums4 = { 1, 2, 3, 4 };
// Все перечисленные выше способы будут равноценны.

string[] people = {"Sam","Peter","Mark"};
#endregion

#region Обращение
// Для обращения к элементам массива используются индексы.
// При этом нумерация начинается с нуля, поэтому индекс первого элемента будет равен 0

int[] myArray = { 1, 2, 3, 4 };
Console.WriteLine(myArray[3]); // 4

//получить элемент массива в переменную
var b = myArray[2]; // 3
Console.WriteLine(b);
//изменить элемент массива по индексу
myArray[0] = 4003;
Console.WriteLine(myArray[0]); // 4003
//массив имеет свойство Length, которое хранит длину массива.
Console.WriteLine(myArray.Length);  // 4
//Благодаря наличию свойства Length, мы можем вычислить индекс последнего элемента массива - это длина массива - 1
Console.WriteLine(myArray[myArray.Length - 1]);   //первый элемент с конца
Console.WriteLine(myArray[myArray.Length - 2]);   //второй элемент с конца
//Однако при подобном подходе выражения типа numbers.Length - 1, смысл которых состоит в том, чтобы получить
//какой-то определенный элемент с конца массива, утяжеляют код. И, начиная, с версии C# 8.0 в язык был добавлен
//специальный оператор ^, с помощью которого можно задать индекс относительно конца коллекции.
Console.WriteLine(myArray[^1]);   //первый элемент с конца
Console.WriteLine(myArray[^2]);   //второй элемент с конца
#endregion

#region Перебор
//Для перебора массивов мы можем использовать различные типы циклов. Например, цикл foreach:
int[] myNewArray = { 1, 5, 7, 34, 5 };
foreach (int i in myNewArray)
{
    Console.Write($"{i}\t");
}
Console.WriteLine();
//Подобные действия мы можем сделать и с помощью цикл for:
for (int i = 0; i < myNewArray.Length; i++)
{
    Console.Write($"{myNewArray[i]}\t");
}
Console.WriteLine();
//В то же время цикл for более гибкий по сравнению с foreach. Если foreach последовательно извлекает элементы
//контейнера и только для чтения, то в цикле for мы можем перескакивать на несколько элементов вперед в зависимости
//от приращения счетчика, а также можем изменять элементы:
for (int i = 0; i < myNewArray.Length; i++)
{
    myNewArray[i] = myNewArray[i] * 2;
    Console.Write($"{myNewArray[i]}\t");
}
Console.WriteLine();
// Также можно использовать и другие виды циклов, например, while:
int[] myNextNewArray = { 33,5,6,88,20 };
int z = 0;
while (z < myNextNewArray.Length)
{
    Console.Write($"{myNextNewArray[z]}\t");
    z++;
}
#endregion

#region Многомерные массивы
//Массивы характеризуются таким понятием как ранг или количество измерений. Выше мы рассматривали массивы,
//которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда
//(строки или столбца) элемента.Но массивы также бывают многомерными. У таких массивов количество измерений
//(то есть ранг) больше 1.

//Массивы которые имеют два измерения (ранг равен 2) называют двухмерными.Например, создадим одномерный и
//двухмерный массивы, которые имеют одинаковые элементы:

int[] myArray1 = { 0, 1, 2, 3, 4, 5 };
int[,] myArray2 = { { 0, 1, 2 }, { 3, 4, 5 } };
// Поскольку массив nums2 двухмерный, он представляет собой простую таблицу. Все возможные способы определения двухмерных массивов:
int[,] tablArray1;
int[,] tablArray2 = new int[2, 3];
int[,] tablArray3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] tablArray4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] tablArray5 = new[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] tablArray6 = { { 0, 1, 2 }, { 3, 4, 5 } };
// Массивы могут иметь и большее количество измерений. Объявление трехмерного массива могло бы выглядеть так:
int[,,] moreDimenstionsArray = new int[2, 3, 4];
// Соответственно могут быть и четырехмерные массивы и массивы с большим количеством измерений. Но на практике
// обычно используются одномерные и двухмерные массивы.
Console.WriteLine();
//Определенную сложность может представлять перебор многомерного массива. Прежде всего надо учитывать, что длина
//такого массива - это совокупное количество элементов.
int[,] numbersZ = { { 1, 2, 3 }, { 4, 5, 6 } };
foreach (int i in numbersZ)
    Console.Write($"{i} ");                  // numbersZ.Length = 6
Console.WriteLine();
//Но что если мы хотим отдельно пробежаться по каждой строке в таблице? В этом случае надо получить количество
//элементов в размерности. В частности, у каждого массива есть метод GetUpperBound(номер_размерности), который
//возвращает индекс последнего элемента в определенной размерности. И если мы говорим непосредственно о двухмерном
//массиве, то первая размерность (с индексом 0) по сути это и есть таблица. И с помощью выражения

int rows = numbersZ.GetUpperBound(0) + 1;  //количество строк
int columns = numbersZ.Length / rows;    //количество столбцов
for (int i = 0; i < rows; i++)
{
    for (int j = 0; j < columns; j++)
    {
        Console.Write($"{numbersZ[i,j]}\t");
    }
    Console.WriteLine();
}
#endregion

#region Массив массивов
//От многомерных массивов надо отличать массив массивов или так называемый "зубчатый массив"
int[][] jawArray1 = new int[3][];
jawArray1[0] = new int[] { 1, 3 };
jawArray1[1] = new int[] { 77, 5, 70 };
jawArray1[2] = new int[] { 6, 7, 8, 54, 12 };

//Здесь две группы квадратных скобок указывают, что это массив массивов, то есть такой массив,
//который в свою очередь содержит в себе другие массивы. Причем длина массива указывается только в
//первых квадратных скобках, все последующие квадратные скобки должны быть пусты: new int[3][].
//В данном случае у нас массив jawArray1 содержит три массива. Причем размерность каждого из этих массивов может не совпадать.
Console.WriteLine();

//Альтернативное определение массива массивов:
int[][] jawArray =
{
    new int[] { 1, 2 },
    new int[] { 77, 5, 70 },
    new int[] { 6, 7, 8, 54, 12},
};

//Используя вложенные циклы, можно перебирать зубчатые массивы. Например:
foreach (int[] row in jawArray)
{
    foreach (int number in row)
    {
        Console.Write("{0}\t",number);
    }
    Console.WriteLine();
}

// перебор с помощью цикла for
for (int i = 0; i < jawArray.Length; i++)
{
    for (int l = 0; l < jawArray[i].Length; l++)   // jawArray[i].Length обращаемся к каждому массиву внутри массива и узнаём длину
    {
        Console.Write($"{jawArray[i][l]} \t");
    }
    Console.WriteLine();
}
#endregion
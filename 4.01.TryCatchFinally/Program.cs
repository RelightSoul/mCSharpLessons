// Обработка исключений      // Конструкция try..catch..finally

//  Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть,
//  а иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться
//  сетевое подключение. такие ситуации называются исключениями. Язык C# предоставляет разработчикам
//  возможности для обработки таких ситуаций.

try
{

}
catch
{

}
finally
{

}

//  При использовании блока try...catch..finally вначале выполняются все инструкции в блоке try.
//  Если в этом блоке не возникло исключений, то после его выполнения начинает выполняться блок
//  finally. И затем конструкция try..catch..finally завершает свою работу.

//  Если же в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается,
//  и среда CLR начинает искать блок catch, который может обработать данное исключение. Если нужный
//  блок catch найден, то он выполняется, и после его завершения выполняется блок finally.

//  Если нужный блок catch не найден, то при возникновении исключения программа аварийно завершает
//  свое выполнение.
try
{
    int x = 5;
    int y = x / 0;
    Console.WriteLine($"Результат: {y}");
}
catch
{

    Console.WriteLine("Возникло исключение!");
}
finally
{
    Console.WriteLine("Блок finally");
}
Console.WriteLine("Конец программы");

//  Следует отметить, что в этой конструкции обязателен блок try. При наличии блока catch мы можем опустить блок finally:
try
{
    int x = 5;
    int y = x / 0;
    Console.WriteLine($"Результат: {y}");
}
catch
{

    Console.WriteLine("Возникло исключение!");
}

//  И, наоборот, при наличии блока finally мы можем опустить блок catch и не обрабатывать исключение:
try
{
    int x = 5;
    int y = x / 0;
    Console.WriteLine($"Результат: {y}");
}
finally
{
    Console.WriteLine("Блок finally");
}
//  Однако поскольку CLR не сможет найти нужный блок catch, то исключение не будет обработано,
//  и программа аварийно завершится.

#region Обработка исключений и условные конструкции
Square("12"); // Квадрат числа 12: 144
Square("ab"); // !Исключение

void Square(string data)
{
    int x = int.Parse(data);
    Console.WriteLine($"Квадрат числа {x}: {x * x}");
}
//  Если пользователь передаст в метод не число, а строку, которая содежит нецифровые символы, то
//  программа выпадет в ошибку. С одной стороны, здесь как раз та ситуация, когда можно применить
//  блок try..catch, чтобы обработать возможную ошибку. Однако гораздо оптимальнее было бы проверить
//  допустимость преобразования:

Square2("12"); // Квадрат числа 12: 144
Square2("ab"); // Некорректный ввод

void Square2(string data)
{
    if (int.TryParse(data, out var x))
    {
        Console.WriteLine($"Квадрат числа {x}: {x * x}");
    }
    else
    {
        Console.WriteLine("Некорректный ввод");
    }
}
//  Метод int.TryParse() возвращает true, если преобразование можно осуществить, и false - если нельзя.
//  С точки зрения производительности использование блоков try..catch более накладно, чем применение
//  условных конструкций. Поэтому по возможности вместо try..catch лучше использовать условные конструкции
//  на проверку исключительных ситуаций
#endregion
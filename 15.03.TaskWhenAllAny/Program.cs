// Последовательное и параллельное выполнение. Task.WhenAll и Task.WhenAny

//  Асинхронный метод может содержать множество выражений await. Когда система встречает в блоке кода
//  оператор await, то выполнение в асинхронном методе останавливается, пока не завершится асинхронная
//  задача. После завершения задачи управление переходит к следующему оператору await и так далее. Это
//  позволяет вызывать асинхронные задачи последовательно в определенном порядке. Например:
await PrintAsync("Hey");
await PrintAsync("What's");
await PrintAsync("Wrong?");

async Task PrintAsync(string mes)
{
    await Task.Delay(1000);
    Console.WriteLine(mes);
}
//  То есть мы видим, что вызовы PrintAsync выполняются последовательно в том порядке, в котором они
//  определены в коде. Каждая задача выполняется как минимум 2 секунды, соответственно общее время
//  выполнения трех задач будет как минимум 6 секунд. И в данном случае вывод строго детерминирован.

//  Нередко такая последовательность бывает необходима, если одна задача зависит от результатов другой.

//  Однако это не всегда необходимо. В подобном случае мы можем сразу запустить все задачи параллельно
//  и применить оператор await там, где необходимо гарантировать завершение выполнения задачи, например,
//  в самом конце программы.
var task1 = PrintAsync("Are");
var task2 = PrintAsync("Anyone");
var task3 = PrintAsync("Here?");

// ожидаем завершения задач
await task1;
await task2;
await task3;
//  В этом случае все задачи запускаются и выполняются параллельно, соответственно общее время выполнения
//  будет меньше 6 секунд, а консольный вывод программы недетерминирован.

//  Однако.NET позволяет упростить отслеживание выполнения набора задач с помощью метода Task.WhenAll.
//  Этот метод принимает набор асинхронных задач и ожидает завершения всех этих задач. Этот метод является
//  аналогом статического метода Task.WaitAll(), однако предназначен непосредственно для асинхронных методов
//  и позволяет применять оператор await:
var task4 = PrintAsync("Look's like");
var task5 = PrintAsync("no one");
var task6 = PrintAsync("here!");

// ожидаем завершения всех задач
await Task.WhenAll(task4,task5,task6);
//  Вначале запускаются три задачи. Затем Task.WhenAll создает новую задачу, которая будет автоматически
//  выполнена после выполнения всех предоставленных задач, то есть задач task1, task2, task3. А с помощью
//  оператора await ожидаем ее завершения.

//  Если нам надо дождаться, когда будет выполнена хотя бы одна задача из некоторого набора задач, то можно
//  применять метод Task.WhenAny(). Это аналог метода Task.WaitAny() -он завершает выполнение, когда завершается
//  хотя бы одна задача. Но для ожидания выполнения к Task.WhenAny() применяется оператор await:
var task7 = PrintAsync("Oh God");
var task8 = PrintAsync("another");
var task9 = PrintAsync("Test=)");

// ожидаем завершения хотя бы одной задачи
await Task.WhenAny(task7,task8,task9);

#region Получение результата
//  Задачи, передаваемые в Task.WhenAll и Task.WhenAny, могут возвращать некоторое значение. В этом случае
//  из методов Task.WhenAll и Task.WhenAny можно получить массив, который будет содержать результаты задач:
var task11 = SquareAsync(4);
var task22 = SquareAsync(5);
var task33 = SquareAsync(6);

int[] results = await Task.WhenAll(task11, task22, task33);
for (int i = 0; i < results.Length; i++)
{
    Console.WriteLine(results[i]);
}

async Task<int> SquareAsync(int n)
{
    await Task.Delay(1000);
    return n * n;
}
Console.ReadLine();
//  В данном случае метод Square возвращает число int - квадрат передаваемого в метод числа. И переменная
//  results будет содержать результат вызова Task.WhenAll - по сути результаты всех трех запущенных задач.
//  Поскольку все передаваемые в Task.WhenAll задачи возвращают int, то соответственно результат Task.WhenAll
//  будет представлять массив значений int.

//Также после завершения задачи ее результат можно получить стандартным образом через свойство Result:
Console.WriteLine($"Result task22 = {task22.Result}");   // Result task22 = 25
#endregion
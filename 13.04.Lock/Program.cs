//  Синхронизация потоков

//  Нередко в потоках используются некоторые разделяемые ресурсы, общие для всей программы. Это могут быть
//  общие переменные, файлы, другие ресурсы. Например:
using System.Threading;

int x = 0;

//запускаем пять потоков
//for (int i = 1; i < 6; i++)
//{
//    Thread myThread = new Thread(Print);
//    myThread.Name = $"Поток {i}";   //// устанавливаем имя для каждого потока
//    myThread.Start();
//}

void Print()
{
    x = 1;
    for (int i = 1; i < 6; i++)
    {
        Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
        x++;
        Thread.Sleep(100);
    }
}
//  Здесь у нас запускаются пять потоков, которые вызывают метод Print и которые работают с общей переменной x.
//  И мы предполагаем, что метод выведет все значения x от 1 до 5. И так для каждого потока. Однако в реальности
//  в процессе работы будет происходить переключение между потоками, и значение переменной x становится
//  непредсказуемым. 

//  Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам
//  на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock
//  определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до
//  завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий
//  поток не освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим
//  образом:

int y = 0;
object locker = new();  // объект-заглушка
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print2);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}


void Print2()
{
    lock (locker)
    {
        y = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {y}");
            y++;
            Thread.Sleep(100);
        }
    }
}
//  Для блокировки с ключевым словом lock используется объект-заглушка, в данном случае это переменная locker.
//  Обычно это переменная типа object. И когда выполнение доходит до оператора lock, объект locker блокируется,
//  и на время его блокировки монопольный доступ к блоку кода имеет только один поток. После окончания работы
//  блока кода, объект locker освобождается и становится доступным для других потоков.

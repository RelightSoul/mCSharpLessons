// Интерфейс представляет некое описание типа, набор компонентов, который должен иметь тип данных.
// И, собственно, мы не можем создавать объекты интерфейса напрямую с помощью конструктора, как например, в классах:

//  Интерфейс представляет некое описание типа, набор компонентов, который должен иметь тип данных. И, собственно,
//  мы не можем создавать объекты интерфейса напрямую с помощью конструктора.

//  В конечном счете интерфейс предназначен для реализации в классах и структурах.
interface IMoveable
{
    void Move();
}
class Person : IMoveable
{
    public void Move()
    {
        Console.WriteLine("Человек идёт");
    }
}
class Car : IMoveable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
//  При применении интерфейса, как и при наследовании после имени класса или структуры указывается двоеточие и
//  затем идут названия применяемых интерфейсов. При этом класс должен реализовать все методы и свойства применяемых
//  интерфейсов, если эти методы и свойства не имеют реализации по умолчанию.

//  Если методы и свойства интерфейса не имеют модификатора доступа, то по умолчанию они являются публичными,
//  при реализации этих методов и свойств в классе и структуре к ним можно применять только модификатор public.

class Program
{
    static void Main(string[] args)
    {
        // -----  Применение интерфейса в программе -----
        Person person = new Person();
        Car car = new Car();
        DoAction(car);
        DoAction(person);
        car.Move();
        person.Move();

        void DoAction(IMoveable act) => act.Move();
        Console.WriteLine();

        // -----  Пример Реализация интерфейсов по умолчанию  -----
        IMovable2 alex = new Person2();
        Car2 car2 = new Car2();
        alex.Move();
        car2.Move();
        //Стоит отметить, что хотя для объекта класса Person мы можем вызвать метод Move - ведь класс Person применяет
        //интерфейс IMovable, тем не менее мы не можем написать так:
        //          Person tom = new Person();
        //          tom.Move();     // Ошибка - метод Move не определен в классе Person
        Console.WriteLine();

        // -----  Пример Множественная реализация интерфейсов  -----
        Message message = new Message("Hey man");
        message.Print();

        // -----  Интерфейсы в преобразованиях типов  -----
        // Все объекты Message являются объектами IMessage
        IMessage hey = new Message("Привет");
        Console.WriteLine(hey.Text);
        // Не все объекты IMessage являются объектами Message, необходимо явное приведение
        // Message someMessage = hey; // ! Ошибка

        // Интерфейс IMessage не имеет свойства Print, необходимо явное приведение
        // hello.Print();  // ! Ошибка

        // если hello представляет класс Message, выполняем преобразование
        if (hey is Message someMessage) someMessage.Print();
        //Преобразование от класса к его интерфейсу, как и преобразование от производного типа к базовому,
        //выполняется автоматически. Так как любой объект Message реализует интерфейс IMessage.

        //Обратное преобразование -от интерфейса к реализующему его классу будет аналогично преобразованию от базового
        //класса к производному.Так как не каждый объект IMessage является объектом Message(ведь интерфейс IMessage
        //могут реализовать и другие классы), то для подобного преобразования необходима операция приведения типов.
        //И если мы хотим обратиться к методам класса Message, которые не определены в интерфейсе IMessage, но являются
        //частью класса Message, то нам надо явным образом выполнить преобразование типов.
    }
}
//  В данной программе определен метод DoAction(), который в качестве параметра принимает объект интерфейса
//  IMovable. На момент написания кода мы можем не знать, что это будет за объект - какой-то класс или структура.
//  Единственное, в чем мы можем быть уверены, что этот объект обязательно реализует метод Move и мы можем вызвать
//  этот метод.

//  Иными словами, интерфейс - это контракт, что какой-то определенный тип обязательно реализует некоторый функционал.

#region Реализация интерфейсов по умолчанию
interface IMovable2
{
    void Move() => Console.WriteLine("Walking");
}
class Person2 : IMovable2 { }
class Car2 : IMovable2
{
    public void Move() => Console.WriteLine("Driving");
}
//  В данном случае интерфейс IMovable определяет реализацию по умолчанию для метода Move. Класс Person не реализует
//  этот метод, поэтому он применяет реализацию по умолчанию в отличие от класса Car, который определяет свою реализацию
//  для метода Move. Пример в Program.
#endregion

#region Множественная реализация интерфейсов
//  Интерфейсы имеют еще одну важную функцию: в C# не поддерживается множественное наследование, то есть мы можем унаследовать
//  класс только от одного класса, в отличие, скажем, от языка С++, где множественное наследование можно использовать.
//  Интерфейсы позволяют частично обойти это ограничение, поскольку в C# классы и структуры могут реализовать сразу несколько
//  интерфейсов. Все реализуемые интерфейсы указываются через запятую:
//          class myClass : myInterface1, myInterface2, myInterface3, ...
//          {

//          }

interface IMessage
{
    string Text { get; set; }
}
interface IPrintable
{
    void Print();
}
class Message : IMessage, IPrintable
{
    public string Text { get; set; }
    public Message(string text) => Text = text;
    public void Print() => Console.WriteLine(Text);
}
//  В данном случае определены два интерфейса. Интерфейс IMessage определяет свойство Text, которое представляет текст
//  сообщения. А интерфейс IPrintable определяет метод Print.
#endregion

#region Интерфейсы в преобразованиях типов
//  Все сказанное в отношении преобразования типов характерно и для интерфейсов. Поскольку класс Message реализует
//  интерфейс IMessage, то переменная типа IMessage может хранить ссылку на объект типа Message. Пример в Program.
#endregion
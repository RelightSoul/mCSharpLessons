//  Рефлексия
//  Введение в рефлексию. Класс System.Type

//  Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение
//  содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из
//  которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы
//  приложения. То есть основная задача рефлексии - это исследование типов.

//  Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. В нем мы можем выделить
//  следующие основные классы:
//  Assembly: класс, представляющий сборку и позволяющий манипулировать этой сборкой
//  AssemblyName: класс, хранящий информацию о сборке
//  MemberInfo: базовый абстрактный класс, определяющий общий функционал для классов EventInfo, FieldInfo,
//  MethodInfo и PropertyInfo    
//  EventInfo: класс, хранящий информацию о событии
//  FieldInfo: хранит информацию об определенном поле типа
//  MethodInfo: хранит информацию об определенном методе
//  PropertyInfo: хранит информацию о свойстве
//  ConstructorInfo: класс, представляющий конструктор
//  Module: класс, позволяющий получить доступ к определенному модулю внутри сборки
//  ParameterInfo: класс, хранящий информацию о параметре метода

//  Эти классы представляют составные блоки типа и приложения: методы, свойства и т.д. Но чтобы получить
//  информацию о членах типа, нам надо воспользоваться классом System.Type.

//  Класс Type представляет изучаемый тип, инкапсулируя всю информацию о нем. С помощью его свойств и
//  методов можно получить эту информацию. Некоторые из его свойств и методов:
//  Метод FindMembers() возвращает массив объектов MemberInfo данного типа
//  Метод GetConstructors() возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo
//  Метод GetEvents() возвращает все события данного типа в виде массива объектов EventInfo
//  Метод GetFields() возвращает все поля данного типа в виде массива объектов FieldInfo
//  Метод GetInterfaces() получает все реализуемые данным типом интерфейсы в виде массива объектов Type
//  Метод GetMembers() возвращает все члены типа в виде массива объектов MemberInfo
//  Метод GetMethods() получает все методы типа в виде массива объектов MethodInfo
//  Метод GetProperties() получает все свойства в виде массива объектов PropertyInfo
//  Свойство Name возвращает имя типа
//  Свойство Assembly возвращает название сборки, где определен тип
//  Свойство Namespace возвращает название пространства имен, где определен тип
//  Свойство IsArray возвращает true, если тип является массивом
//  Свойство IsClass возвращает true, если тип представляет класс
//  Свойство IsEnum возвращает true, если тип является перечислением
//  Свойство IsInterface возвращает true, если тип представляет интерфейс

#region Получение типа
//  Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить данный тип. Это можно
//  сделать тремя способами: с помощью оператора typeof, с помощью метода GetType() класса Object и применяя
//  статический метод Type.GetType().

//  Получение типа через typeof:
Type myType = typeof(Person);

//  Получение типа с помощью метода GetType, унаследованного от класса Object:
Person tom = new Person("Tom");
Type myType2 = tom.GetType();

//  третий способ получения типа - статический метод Type.GetType():
Type? myType3 = Type.GetType("Person",true,false);
//  Первый параметр указывает на полное имя класса с пространством имен. Второй параметр указывает, будет ли
//  генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что
//  исключение не будет генерироваться. И третий параметр указывает, надо ли учитывать регистр символов в
//  первом параметре. Значение true означает, что регистр игнорируется. Поскольку указанный тип может
//  отсутствовать, то метод возвращает объект nullable-типа

//  Если нужный нам тип находится в другой сборке dll, то после полного имени класса через запятую указывается
//  имя сборки:
//          	Type myType = Type.GetType("PeopleTypes.Person, MyLibrary", false, true);

//  Теперь исследуем тип и получим некоторую информацию о нем.
Type _myType = typeof(Person);
Console.WriteLine(_myType.Name);         // получаем краткое имя типа
Console.WriteLine(_myType.FullName);     // получаем полное имя типа
Console.WriteLine(_myType.Namespace);    // получаем пространство имен типа
Console.WriteLine(_myType.IsValueType);  // является ли тип структурой
Console.WriteLine(_myType.IsClass);      // является ли тип классом
#endregion

#region Поиск реализованных интерфейсов
//  Чтобы получить все реализованные типом интерфейсы, надо использовать метод GetInterfaces(), который
//  возвращает массив объектов Type:
Type myType4 = typeof(Person2);
foreach (Type type in myType4.GetInterfaces())
{
    Console.WriteLine(type.Name);
}
//  Так как каждый интерфейс представляет объект Type, то для каждого полученного интерфейса можно также
//  применить выше рассмотренные методы для извлечения информации о свойствах и методах

//  Но пока все примеры выше никак не использовали рефлексию. В следующих темах рассмотрим, как можно с
//  помощью рефлексии получать компоненты типа и обращаться к ним, например, изменять значения приватных
//  полей класса.







public class Person2 : IEater, IMovable
{
    public string Name { get; set; }
    public Person2(string name)
    {
        Name = name;
    }    
    public void Eat()
    {
        Console.WriteLine("Eat"); ;
    }
    public void Move()
    {
        Console.WriteLine("Move"); ;
    }
}
interface IEater
{
    void Eat();
}
interface IMovable
{
    void Move();
}
#endregion
record Person (string Name);
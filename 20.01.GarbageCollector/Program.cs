//  Сборка мусора, управление памятью и указатели
//  Сборщик мусора в C#

//  Ранее в теме Типы значений и ссылочные типы мы рассматривали отдельные типы данных и как они располагаются
//  в памяти. Так, при использовании переменных типов значений в методе, все значения этих переменных попадают
//  в стек. После завершения работы метода стек очищается.

//  При использовании же ссылочных типов, например, объектов классов, для них также будет отводиться место в
//  стеке, только там будет храниться не значение, а адрес на участок памяти в хипе или куче, в котором и будут
//  находиться сами значения данного объекта. И если объект класса перестает использоваться, то при очистке стека
//  ссылка на участок памяти также очищается, однако это не приводит к немедленной очистке самого участка памяти
//  в куче. Впоследствии сборщик мусора (garbage collector) увидит, что на данный участок памяти больше нет
//  ссылок, и очистит его.

//  Например:
Test();

void Test()
{
    Person tom = new Person("Tom");
    Console.WriteLine(tom.Name);
}
record class Person(string Name);
//  В методе Test создается объект Person. С помощью оператора new в куче для хранения объекта CLR выделяет
//  участок памяти. А в стек добавляет адрес на этот участок памяти. В неявно определенном методе Main мы
//  вызываем метод Test. И после того, как Test отработает, место в стеке очищается, а сборщик мусора очищает
//  ранее выделенный под хранение объекта Person участок памяти.

//  Сборщик мусора не запускается сразу после удаления из стека ссылки на объект, размещенный в куче. Он
//  запускается в то время, когда среда CLR обнаружит в этом потребность, например, когда программе требуется
//  дополнительная память.

//  Как правило, объекты в куче располагаются неупорядочено, между ними могут иметься пустоты. Куча довольно
//  сильно фрагментирована. Поэтому после очистки памяти в результате очередной сборки мусора оставшиеся
//  объекты перемещаются в один непрерывный блок памяти. Вместе с этим происходит обновление ссылок, чтобы
//  они правильно указывали на новые адреса объектов.

//  Так же надо отметить, что для крупных объектов существует своя куча - Large Object Heap. В эту кучу
//  помещаются объекты, размер которых больше 85 000 байт. Особенность этой кучи состоит в том, что при
//  сборке мусора сжатие памяти не проводится по причине больших издержек, связанных с размером объектов.

//  Несмотря на то что, на сжатие занятого пространства требуется время, да и приложение не сможет продолжать
//  работу, пока не отработает сборщик мусора, однако благодаря подобному подходу также происходит оптимизация
//  приложения. Теперь чтобы найти свободное место в куче среде CLR не надо искать островки пустого пространства
//  среди занятых блоков. Ей достаточно обратиться к указателю кучи, который указывает на свободный участок
//  памяти, что уменьшает количество обращений к памяти.

//  Кроме того, чтобы снизить издержки от работы сборщика мусора, все объекты в куче разделяются по поколениям.
//  Всего существует три поколения объектов: 0, 1 и 2 - е.

//  К поколению 0 относятся новые объекты, которые еще ни разу не подвергались сборке мусора. К поколению 1
//  относятся объекты, которые пережили одну сборку, а к поколению 2 - объекты, прошедшие более одной сборки
//  мусора.

//  Когда сборщик мусора приступает к работе, он сначала анализирует объекты из поколению 0. Те объекты, которые
//  остаются актуальными после очистки, повышаются до поколения 1.

//  Если после обработки объектов поколения 0 все еще необходима дополнительная память, то сборщик мусора
//  приступает к объектам из поколения 1. Те объекты, на которые уже нет ссылок, уничтожаются, а те, которые
//  по-прежнему актуальны, повышаются до поколения 2.

//  Поскольку объекты из поколения 0 являются более молодыми и нередко находятся в адресном пространстве
//  памяти рядом друг с другом, то их удаление проходит с наименьшими издержками.

#region Класс System.GC
//  Функционал сборщика мусора в библиотеке классов .NET представляет класс System.GC. Через статические методы
//  данный класс позволяет обращаться к сборщику мусора. Как правило, надобность в применении этого класса
//  отсутствует. Наиболее распространенным случаем его использования является сборка мусора при работе с
//  неуправляемыми ресурсами, при интенсивном выделении больших объемов памяти, при которых необходимо такое
//  же быстрое их освобождение.

//  Рассмотрим некоторые методы и свойства класса System.GC:

//  Метод AddMemoryPressure информирует среду CLR о выделении большого объема неуправляемой памяти, которую
//  надо учесть при планировании сборки мусора. В связке с этим методом используется метод RemoveMemoryPressure,
//  который указывает CLR, что ранее выделенная память освобождена, и ее не надо учитывать при сборке мусора.

//  Метод Collect приводит в действие механизм сборки мусора. Перегруженные версии метода позволяют указать
//  поколение объектов, вплоть до которого надо произвести сборку мусора

//  Метод GetGeneration(Object) позволяет определить номер поколения, к которому относится переданый в качестве
//  параметра объект

//  Метод GetTotalMemory возвращает объем памяти в байтах, которое занято в управляемой куче

//  Метод WaitForPendingFinalizers приостанавливает работу текущего потока до освобождения всех объектов, для
//  которых производится сборка мусора

//  Работать с методами System.GC несложно:

//      // .................................
//      long totalMemory = GC.GetTotalMemory(false);

//      GC.Collect();
//      GC.WaitForPendingFinalizers();
//      //......................................

//  С помощью перегруженных версий метода GC.Collect можно выполнить более точную настройку сборки мусора.
//  Так, его перегруженная версия принимает в качестве параметра число - номер поколения, вплоть до которого
//  надо выполнить очистку. Например, GC.Collect(0) -удаляются только объекты поколения 0.

//  Еще одна перегруженная версия принимает еще и второй параметр - перечисление GCCollectionMode. Это
//  перечисление может принимать три значения:

//  Default: значение по умолчанию для данного перечисления (Forced)

//  Forced: вызывает немедленное выполнение сборки мусора

//  Optimized: позволяет сборщику мусора определить, является ли текущий момент оптимальным для сборки мусора

//  Например, немедленная сборка мусора вплоть до первого поколения объектов: GC.Collect(1,
//  GCCollectionMode.Forced);
#endregion
// Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов
// и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.


#region Определение интерфейса
//  Для определения интерфейса используется ключевое слово interface. Как правило, названия интерфейсов в C# начинаются
//  с заглавной буквы I, например, IComparable, IEnumerable (так называемая венгерская нотация), однако это не обязательное
//  требование, а больше стиль программирования.

//   В целом интерфейсы могут определять следующие сущности:
//Методы

//Свойства

//Индексаторы

//События

//Статические поля и константы (начиная с версии C# 8.0)

//  Однако интерфейсы не могут определять нестатические переменные. Например, простейший интерфейс, который определяет
//  все эти компоненты:

interface IMovable
{
    // константа
    const int minSpeed = 0;
    // статическая переменная
    static int maxSpeed = 60;
    // метод
    void Move();
    // свойство
    string Name { get; set; }

    delegate void MoveHandler(string message);     // определение делегата для события
    // событие
    event MoveHandler MoveEvent;
}

//  В данном случае определен интерфейс IMovable, который представляет некоторый движущийся объект. Данный интерфейс
//  содержит различные компоненты, которые описывают возможности движущегося объекта. То есть интерфейс описывает
//  некоторый функционал, который должен быть у движущегося объекта.

//  Методы и свойства интерфейса могут не иметь реализации, в этом они сближаются с абстрактными методами и свойствами
//  абстрактных классов. В данном случае интерфейс определяет метод Move, который будет представлять некоторое
//  передвижение. Он не имеет реализации, не принимает никаких параметров и ничего не возвращает.

//  То же самое в данном случае касается свойства Name. На первый взгляд оно похоже на автоматическое свойство.
//  Но в реальности это определение свойства в интерфейсе, которое не имеет реализации, а не автосвойство.
#endregion

#region Модификаторы доступа
//  Еще один момент в объявлении интерфейса: если его члены - методы и свойства не имеют модификаторов доступа, то фактически
//  по умолчанию доступ public, так как цель интерфейса - определение функционала для реализации его классом. Это касается
//  также и констант и статических переменных, которые в классах и структурах по умолчанию имееют модификатор private.
//  В интерфейсах же они имеют по умолчанию модификатор public. И например, мы могли бы обратиться к константе minSpeed
//  и переменной maxSpeed интерфейса IMovable:

//      Console.WriteLine(IMovable.maxSpeed);   // 60
//      Console.WriteLine(IMovable.minSpeed);   // 0

//  Начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у компонентов интерфейса:
public interface IMovable2
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    public void Move();
    protected internal string Name { get; set; }    // название
    public delegate void MoveHandler(string message);  // определение делегата для события
    public event MoveHandler MoveEvent;    // событие движения
}
//  Как и классы, интерфейсы по умолчанию имеют уровень доступа internal, то есть такой интерфейс доступен
//  только в рамках текущего проекта. Но с помощью модификатора public мы можем сделать интерфейс общедоступным.
#endregion

#region Реализация по умолчанию
//  Также начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Это значит,
//  что мы можем определить в интерфейсах полноценные методы и свойства, которые имеют реализацию как в обычных
//  классах и структурах. Например, определим реализацию метода Move по умолчанию:
interface IMovable3
{
    // реализация метода по умолчанию
    void Move()
    {
        Console.WriteLine("Перемещаюсь");
    }
}
//  С реализацией свойств по умолчанию в интерфейсах дело обстоит несколько сложнее, поскольку мы не можем определять
//  в интерфейсах нестатические переменные, соответственно в свойствах интерфейса мы не можем манипулировать состоянием
//  объекта. Тем не менее реализацию по умолчанию для свойств мы тоже можем определять:
interface IMovable4
{
    // реализация свойства по умолчанию
    // свойство только для чтения
    public int MaxSpeed { get {return 0;} }
}

//Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private), то они должны
//иметь реализацию по умолчанию. То же самое относится к любым статическим методам и свойствам (не обязательно приватным):

interface IMovable5
{
    public const int minSpeed = 0;
    private static int maxSpeed = 60;
    static double GetTime(double distance, double speed) => distance / speed;
    static int MaxSpeed 
    {
        get => maxSpeed;
        set 
        {
            if (value < minSpeed) maxSpeed = value;
        }
    }
}
#endregion

//  Указатели на структуры, члены классов и массивы

#region Указатели на типы и операция ->
//  Кроме указателей на простые типы можно использовать указатели на структуры. А для доступа к полям
//  структуры, на которую указывает указатель, используется операция ->:
unsafe
{
    Point point = new Point(0,0);
    Console.WriteLine(point);  // X: 0  Y: 0
    Point* p = &point;
    p->X = 30;
    Console.WriteLine(p->X);

    // разыменовывание указателя
    (*p).Y = 180;
    Console.WriteLine((*p).Y);
    Console.WriteLine(point);  // X: 30  Y: 180
}
//  Обращаясь к указателю p->X = 30; мы можем получить или установить значение свойства структуры, на которую
//  указывает указатель. Обратите внимание, что просто написать p.X=30 мы не можем, так как p - это не
//  структура Point, а указатель на структуру.

//  Альтернативой служит операция разыменования: (*p).X = 30;

//  Стоит отметить, что указатель может указывать только на те структуры, которые не имеют полей ссылочных
//  типов (в том числе полей, которые генерируются компилятором автоматически для автосвойств).
#endregion

#region Указатели на массивы и stackalloc
//  С помощью ключевого слова stackalloc можно выделить память под массив в стеке. Смысл выделения памяти в
//  стеке в повышении быстродействия кода. Посмотрим на примере вычисления квадратов чисел:
unsafe
{
    const int size = 7;
    int* square = stackalloc int[size];  // выделяем память в стеке под семь объектов int
    int* p = square;
    // вычисляем квадраты чисел от 1 до 7 включая
    for (int i = 1; i < size; i++,p++)
    {
        *p = i * i;
    }
    for (int i = 0; i < size; i++)
    {
        Console.WriteLine(square[i]);
    }
}
//  Оператор stackalloc принимает после себя массив, на который будет указывать указатель. int* square =
//  stackalloc int[size];.

//  Для манипуляций с массивом создаем указатель p: int* p = square;, который указывает на первый элемент
//  массива, в котором всего 7 элементов. То есть с помощью указателя p мы сможем перемещаться по массиву square.

//  Далее в цикле происходит подсчет квадратов чисел от 1 до 7. В цикле для установки значения (квадрата
//  числа - i * i) по адресу, который хранит указатель, выполняется выражение:
//  * p = i * i;

//  Затем происходит инкремент указателя p++, и указатель p смещается вперед на следующий элемент в массиве square
#endregion

#region Оператор fixed и закрепление указателей
//  Ранее мы посмотрели, как создавать указатели на типы значений, например, int или структуры. Однако кроме
//  структур в C# есть еще и классы, которые в отличие от типов значений, помещают все связанные значения в куче.
//  И в работу данных классов может в любой момент вмешаться сборщик мусора, периодически очищающий кучу.
//  Чтобы фиксировать на все время работы указатели на объекты классов используется оператор fixed.
unsafe
{
    Point2 point = new Point2();

    // блок фиксации указателя
    fixed (int* pX = &point.x)
    {
        *pX = 30;
    }
    fixed (int* pY = &point.y)
    {
        *pY = 150;
    }
    // можно совместить оба блока
    /*fixed (int* pX = &point.x, pY = &point.y)
    {
        *pX = 30;
        *pY = 150;
    }*/
    Console.WriteLine(point); // x: 30  y: 150
}
//  Оператор fixed создает блок, в котором фиксируется указатель на поле объекта person. После завершения
//  блока fixed закрепление с переменных снимается, и они могут быть подвержены сборке мусора.

//  Кроме адреса переменной можно также инициализировать указатель, используя массив, строку или буфер
//  фиксированного размера:
unsafe
{
    int[] nums = { 0, 1, 2, 3, 7, 88 };
    string str = "Привет мир";
    fixed (int* p = nums)
    {
        int third = *(p + 2);     // получим третий элемент
        Console.WriteLine(third); // 2
    }
    fixed (char* p = str)
    {
        char forth = *(p + 3);     // получим четвертый элемент
        Console.WriteLine(forth); // в
    }
}
//  При инициализации указателей на строку следует учитывать, что указатель должен иметь тип char*.
#endregion

class Point2
{
    public int x;
    public int y;
    public override string ToString() => $"x: {x}  y: {y}";
}
struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    public Point(int x, int y)
    {
        X = x; Y = y;
    }
    public override string ToString()
    {
        return $"X = {X} Y = {Y}";
    }
}

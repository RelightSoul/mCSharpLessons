// Один обобщенный класс может быть унаследован от другого обобщенного. 

//  Можно использовать различные варианты наследования.

//  Первый вариант заключается в создание класса-наследника, который типизирован тем же типом, что и базовый:
class Person <T>
{
    public T Id { get; }
    public Person(T id)
    {
        Id = id;    
    }
}
class UniversalPerson<T> : Person<T>
{
    public UniversalPerson(T id) : base(id)
    {
    }
}

//  Второй вариант представляет создание обычного необобщенного класса-наследника. В этом случае при
//  наследовании у базового класса надо явным образом определить используемый тип:
class StringPerson : Person<string>   //Нужно указать явно
{
    public StringPerson(string id) : base(id)
    {
    }
}

//  Третий вариант представляет типизацию производного класса параметром совсем другого типа, отличного
//  от универсального параметра в базовом классе. В этом случае для базового класса также надо указать
//  используемый тип:

class IntPerson<T, K> : Person<int>
    where T : struct
    where K : Person<int>
{
    public IntPerson(int id) : base(id)
    {
    }
}

//  Также в классах-наследниках можно сочетать использование универсального параметра из базового класса
//  с применением своих параметров:

class MixedPerson<T, K> : Person<T>
    where K : class
{
    public MixedPerson(T id) : base(id)
    {
    }
}

//  стоит учитывать, что если на уровне базового класса для универсального параметра установлено ограничение,
//  то подобное ограничение должно быть определено и в производных классах, которые также используют
//  этот параметр:

class Person2<T> where T : class
{
    public T Id { get; }
    public Person2(T id) => Id = id;
}
class UniversalPerson2<T> : Person2<T> where T : class
{
    public UniversalPerson2(T id) : base(id) { }
}